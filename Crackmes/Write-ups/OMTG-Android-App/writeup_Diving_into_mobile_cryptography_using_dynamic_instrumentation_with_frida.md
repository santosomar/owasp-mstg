# Diving into mobile cryptography using dynamic instrumentation with frida

> Author: Carlos Holguera


## Background: why are we doing this?

Google says that they have implemented Key Extraction Prevention: https://developer.android.com/training/articles/keystore#ExtractionPrevention

If you are like me you won't just believe that this statement is true. You will try to verify this yourself.

## Spoiler: what will we learn?

We have learnt:
- how to hook a method to know when they are being called and print their parameters.
- how to hook a method to replace it's implementation/return value on runtime in order to bypass some checks being made by an app.
- how to deal with errors and exceptions when running frida scripts.
- how to use the documentation for app developers to help us writing frida scripts.
- how to decode cryptographic keys (if we even get to extract them) and understand their values using an RFC.
- about the Java Cipher operation modes.


## Preparations
We will work with the [OMTG app][OMTGApp]. For this to work we will use Android 5 and Android 7 because they use different Java classes to handle the private keys.

### Android 5

- Create a virtual device with the following parameters:
  `Nexus 5 API 22        1080 × 1920: xxhdpi    22    Android 5.1    x86_64    4 GB`

- Download the Android 5 APK:
  <https://github.com/OWASP/MSTG-Hacking-Playground/blob/master/Android/OMTG-Android-App/app/app-x86-debug-Android5.apk>
- and install it:
  ```
  adb install ~/Downloads/app-x86-debug_android5.apk
  ```

- Download the [x86 version of frida-server][x86fridaserver] and push it to the emulator:
  ```
  adb push ./Downloads/frida-server-11.0.3-android-x86 /data/local/tmp/
  ```
- Run the frida-server on the emulator:
  ```
  adb shell
  su # if needed
  cd /data/local/tmp/
  chmod 755 frida-server-11.0.3-android-x86
  ./frida-server-11.0.3-android-x86 &
  ```

Note: if we run this version on Android 7 we will get this Exception:
`android.security.keystore.AndroidKeystoreRSAPrivateKey cannot be cast to java.security.interfaces.RSAPrivateKey`
I was working with Sven to fix this and he updated the code so if you get the last version it will run on Android 7.

You can get both APKs here, both for the emulator and for real devices:

<https://github.com/OWASP/MSTG-Hacking-Playground/tree/master/Android/OMTG-Android-App/app>

### Android 7/8

- Create a virtual device with the following parameters:
  `Nexus 5 API 24        1080 × 1920: xxhdpi    24    Android 7.0    x86_64    2 GB`

- Download the Android 7 APK:
  <https://github.com/OWASP/MSTG-Hacking-Playground/blob/master/Android/OMTG-Android-App/app/app-x86-debug.apk>
- and install it:
  ```
  adb install ~/Downloads/app-x86-debug.apk
  ```
- Download the [x86_64 version of frida-server][x8664fridaserver] and push it to the emulator:
  ```
  adb push ./Downloads/frida-server-11.0.3-android-x86_64 /data/local/tmp/
  ```
- Run the frida-server on the emulator:
  ```
  adb shell
  su # if needed
  cd /data/local/tmp/
  chmod 755 frida-server-11.0.3-android-x86_64
  ./frida-server-11.0.3-android-x86_64 &
  ```

## The Goal
The goal is to extract the cryptographic keys (bytes) used by the app. The OMTG app contains the class `OMTG_DATAST_001_KeyStore`, it presents a form where a plaintext can be inserted and it can be encrypted with a key that is generated by the app. Afterwards the encrypted string can be again decrypted.

## Let's get started

>Please use the Android 5 setup and binaries from now on!

The part of the app that is interesting to us is the `decryptString` method of [OMTG_DATAST_001_KeyStore_f412226f1b][], as it uses the private key that we want to extract.

For this part it is important that you take a look at the right version in the repo. Here is the link to the right source code:


```
public void decryptString(String alias) {
     try {
         KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null);
         RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey();

         Log.e(TAG, String.valueOf(privateKeyEntry.getPrivateKey().getEncoded()));

         Cipher output = Cipher.getInstance("RSA/ECB/PKCS1Padding", "AndroidOpenSSL");
         output.init(Cipher.DECRYPT_MODE, privateKey);
```

### First warmup: a simple hook with Frida

Create a file called hook_decryptString.js (name it as you want).
```
Java.perform(function(){
  console.log("[*] script loaded");
  var clazz = Java.use("sg.vp.owasp_mobile.OMTG_Android.OMTG_DATAST_001_KeyStore");

  clazz.decryptString.overload("java.lang.String").implementation = function (alias) {
    console.log("[*] decryptString called");
    console.log("[*] alias: " + alias);

    this.decryptString.overload("java.lang.String").call(this, alias);
  };
});
```
Open the app and press the `OMTG_DATAST_001_KeyStore` button.

With the terminal pointing to the directory where this files is we will run the following:

`frida -U sg.vp.owasp_mobile.OMTG_Android -l hook_decryptString.js`

The frida cli will open, connect to the device (`-U`) and will load the script (`-l`).

From now on, every time we click on decrypt it will print a log as indicated in our script.

```
[*] script loaded
[Android Emulator 5554::sg.vp.owasp_mobile.OMTG_Android]-> [*] decryptString called
[*] alias: Dummy
[*] decryptString called
[*] alias: Dummy
```

### Let's get to the crypto

Cool, now we are able to hook any method of any class. Let's use this knowledge to hook the crypto related classes. If we take a look again at the source code we will see that the `init` method of Cipher is the one that will give us access to the instances of RSAPublicKey and RSAPrivateKey.

This `init` method receives a `mode` and a `key`, we can look up this in the Android developer reference for the [Cipher][] class.

> Within a class, a method might implement a different set of parameters, each of these implementations of the method is called a overload.

The init method of Cipher has multiple overloads. The one we need is:

```
init(int opmode, Key key)
Initializes this cipher with a key.
```

So first we can simply hook the method like this:

> Remember to enclose all hooks in `Java.perform(function(){});`. I will be omitting this for the rest of the write-up.

```
var Cipher = Java.use("javax.crypto.Cipher");
Cipher.init.overload('int', 'java.security.Key').implementation  = function(opmode, key){
    console.log("[*] Cipher.init called");
    this.init.overload('int', 'java.security.Key').call(this, opmode, key);
}
```

Output:
```
[*] script loaded
[Android Emulator 5554::sg.vp.owasp_mobile.OMTG_Android]-> [*] Cipher.init called
[*] Cipher.init called
```

Note about the operation mode: The operation mode in a Cipher may have two different values: [DECRYPT_MODE][] (2) and [ENCRYPT_MODE][] (1). They are used to initialize cipher to decryption mode and encryption mode respectively.

[DECRYPT_MODE]: https://developer.android.com/reference/javax/crypto/Cipher#DECRYPT_MODE
[ENCRYPT_MODE]: https://developer.android.com/reference/javax/crypto/Cipher#ENCRYPT_MODE

Let's use this to differentiate if the Cipher is being initialized for encryption or decryption:

```
var Cipher = Java.use("javax.crypto.Cipher");
Cipher.init.overload('int', 'java.security.Key').implementation  = function(opmode, key){
    console.log("[*] Cipher.init called");
    console.log("[*] mode: " + opmode);

    if (opmode == 2){
      console.log("[*] decryption with private key!");
    }

    else if (opmode == 1){
      console.log("[*] encryption with public key!");
    }

    this.init.overload('int', 'java.security.Key').call(this, opmode, key);
}
```

Whenever we click on encrypt or decrypt we will get this logged.

```
[*] script loaded
[Android Emulator 5554::sg.vp.owasp_mobile.OMTG_Android]-> [*] Cipher.init called
[*] mode: 2
[*] decryption with private key!
[*] Cipher.init called
[*] mode: 1
[*] encryption with public key!
```

But we are interested into getting the crypto keys. As we are dealing with asymmetric crypto and therefore we have a key pair here, we will try to obtain both keys.

We will start with the public key.

### Extracting the public key

If we look at the code we see that this is a [RSAPublicKey][].


Let's modify our script to print the public key:

```
var Cipher = Java.use("javax.crypto.Cipher");
Cipher.init.overload('int', 'java.security.Key').implementation  = function(opmode, key){
    console.log("[*] Cipher.init called");
    console.log("[*] mode: " + opmode);

    if (opmode == 2){
      console.log("[*] decryption with private key!");
    }

    else if (opmode == 1){
      console.log("[*] encryption with public key!");
      var pub_key = Java.cast(key, RSAPublicKey);
      var pub_key2 = Java.cast(key, RSAKey); // We cannot call getModulus() from RSAPublicKey, so we cast it to RSAKey
      console.log("[*] key: " + pub_key.toString());
      console.log("[*] key PublicExponent: " + pub_key.getPublicExponent());
      console.log("[*] key modulus: " + pub_key2.getModulus());
    }

    this.init.overload('int', 'java.security.Key').call(this, opmode, key);
}
```

Note that we had to cast to two different classes in order to get all the values we wanted. I can recommend you to try without the cast so you can see what you can expect as output and then understand why you have to cast it to the right class (remember to check the Android developers reference).

Let's run the script and see what happens:

```
[*] script loaded
[Android Emulator 5554::sg.vp.owasp_mobile.OMTG_Android]-> [*] Cipher.init called
[*] mode: 2
[*] decryption with private key!
[*] Cipher.init called
[*] mode: 1
[*] encryption with public key!
ReferenceError: identifier 'RSAPublicKey' undefined
    at [anon] (duk_js_var.c:1207)
    at [anon] (repl1.js:14)
    at input:1
```
_Oops!_

We want to use the RSAPublicKey and forgot to define it. Remember our first script? There we already used `Java.use` to _use_ a class. Let's add that to our script:

`var RSAPublicKey = Java.use("java.security.interfaces.RSAPublicKey");`

The same goes for RSAKey.

Let's run it again:

```
[*] script loaded
[Android Emulator 5554::sg.vp.owasp_mobile.OMTG_Android]-> [*] Cipher.init called
[*] mode: 1
[*] encryption with public key!
[*] key: OpenSSLRSAPublicKey{modulus=afb1e2b7253ceea3a5db53cefb089400442963423640d3eed7a9b24cc00f314eddeedb436ec5cd72d9a83cbf464d3fadd410efdac9380cf7f521fa99ccec1dea0b47ba373804541eceec9b5224638047a8bf48439e84b15a38b50b9fc52dbcab645e3ca884218cfba7a5184b84e0185797dfd50752135001fd0434be80446ad6ece62eddac54e545ea8f2cd78c21e86bc8207c3348651aa4f8d8463e8c2e78de792a2dac950930ebea0683d552220356f0902b3f668b7e6020bdad99ba2d0455109a193bae9988e06c5e1a9d4c215e2f0eb8c7033f61811153fb9260465100d9ec17011b1df890b0182a245cf1a3f900087972a9adadad584ef8d835c7a46cf3,publicExponent=10001}
[*] key PublicExponent: 65537
[*] key modulus: 22179422031229710591965846750310923034255420116584310057710706135026686724675049414523706843630988433797869586376687057843991070388820398290698136506062536434920947310057949360988213738817267886384969446296504627125956437376327675406890539205930213638005771952192274829635262199914548951218596995122096152620253769865391078393627384455706850029068900827488598607568529131354316779564361744618396122050728512728635078919781544155706896781702070170694877782878520817169021597715647235136095995177148845293348918683798995549277015717102087341557841967425452284378860182934379781671914623496792959408288519418436026395891
```

Note that the toString method prints the keys base64-encoded and the other methods as int/BigInteger. You can check it out, they are the same values :)

So we got the public key, good. This was to expect as it is.. *public*. Let's see what happens with the private key.

### Extracting the private key (?)

For this part it is important that you take a look at the right version in the repo. Here is the link to the right source code:

<https://github.com/OWASP/MSTG-Hacking-Playground/blob/f412226f1bac1958d3f71b0d19eca0dc0905a267/Android/OMTG-Android-App/app/src/main/java/sg/vp/owasp_mobile/OMTG_Android/OMTG_DATAST_001_KeyStore.java#LC173>

Remember that we are working with the Android 5 compatible version of the app.

```
public void decryptString(String alias) {
        try {
            KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null);
            RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey();

            Log.e(TAG, String.valueOf(privateKeyEntry.getPrivateKey().getEncoded()));

            Cipher output = Cipher.getInstance("RSA/ECB/PKCS1Padding", "AndroidOpenSSL");
output.init(Cipher.DECRYPT_MODE, privateKey);
```

As we can see, we have a [RSAPrivateKey][] that gets passed to the Cipher's `init` method (remember that we are working with API 22).

This class has the method `getPrivateExponent` So we can try first the following:

```
...
if (opmode == 2){
  console.log("[*] decryption with private key!");
  console.log("[*] key PrivateExponent: " + key.getPrivateExponent());
...
```

Run it:

```
[*] script loaded
[Android Emulator 5554::sg.vp.owasp_mobile.OMTG_Android]-> [*] decryptString called
[*] alias: Dummy
[*] OpenSSLKey.isEngineBased called
[*] Cipher.init called
[*] mode: 2
[*] decryption with private key!
TypeError: undefined not callable (property 'getPrivateExponent' of [object Object])
    at [anon] (duk_js_call.c:2847)
    at [anon] (repl1.js:41)
    at input:1
```

_Oops!_

We know this error already, let's cast it:

```
if (opmode == 2){
  console.log("[*] decryption with private key!");
  var priv_key = Java.cast(key, RSAPrivateKey);
  console.log("[*] key PrivateExponent: " + priv_key.getPrivateExponent());
```

Run:

```
[*] script loaded
[Android Emulator 5554::sg.vp.owasp_mobile.OMTG_Android]-> [*] decryptString called
[*] alias: Dummy
[*] Cipher.init called
[*] mode: 2
[*] decryption with private key!
```

We do not get any print containing `"[*] key PrivateExponent: "`. And in the emulator we see a toast message with an exception: `Exception private exponent cannot be extracted occured`.

We do not give up and continue.. If you take a look at the Cipher `getInstance` method you can see that it is using the `"AndroidOpenSSL"` cryptographic provider. If you do a little research you will see that it will internally use the class [OpenSSLRSAPrivateKey][] for the RSAPrivateKey. If we take a look at the code we found this method:

```
public final BigInteger getPrivateExponent() {
    if (key.isEngineBased()) {
        throw new UnsupportedOperationException("private exponent cannot be extracted");
    }
    ensureReadParams();
    return privateExponent;
}
```

If we do the casting and run the script again we will get the same exception and it is exactly what's being thrown by the previous method.

```
if (opmode == 2){
  console.log("[*] decryption with private key!");
  //var priv_key = Java.cast(key, RSAPrivateKey);
  var priv_key = Java.cast(key, OpenSSLRSAPrivateKey);
  console.log("[*] key PrivateExponent: " + priv_key.getPrivateExponent());
```

We try next with other method, getEncoded:

```
public final byte[] getEncoded() {
    if (key.isEngineBased()) {
        return null;
    }
    return NativeCrypto.i2d_PKCS8_PRIV_KEY_INFO(key.getPkeyContext());
}
```

We will probably get a null but let's try anyway:

```
if (opmode == 2){
  console.log("[*] decryption with private key!");
  //var priv_key = Java.cast(key, RSAPrivateKey);
  var priv_key = Java.cast(key, OpenSSLRSAPrivateKey);
  //console.log("[*] key PrivateExponent: " + priv_key.getPrivateExponent());
  console.log("[*] Private Key encoded: " + priv_key.getEncoded());
```

> Note that we commented out the first call to getPrivateExponent because it is throwing the exception and this breaks the script. I made this for simplicity, normally you will handle the exceptions in your javascript scripts.

Output:

```
[*] script loaded
[Android Emulator 5554::sg.vp.owasp_mobile.OMTG_Android]-> [*] decryptString called
[*] alias: Dummy
[*] Cipher.init called
[*] mode: 2
[*] decryption with private key!
[*] Private Key encoded: null
```

So the key is null as we can expect from the source code.

We see that this and other methods here are _protected_ by a `isEngineBased` check. This will prevent us from getting this key on the first place, so let's get rid of this check:

```
var OpenSSLKey = Java.use("com.android.org.conscrypt.OpenSSLKey");

OpenSSLKey.isEngineBased.overload().implementation  = function(){
  console.log("[*] OpenSSLKey.isEngineBased called");
  return false;
}
```

In order to test this hook we will call a method where we can sure that we get something back `OpenSSLRSAPrivateKey.getFormat()`:
```    
public final String getFormat() {
    if (key.isEngineBased()) {
        return null;
    }
    return "PKCS#8";
}
```

We will get `"PKCS#8"` or `null` if we run the hook or not. We run it and it goes as expected :)

But let's go back to the `getEncoded` method. This should get us the encoded key bytes. In order to work with `OpenSSLRSAPrivateKey` on frida we have to cast it:
```
var priv_key = Java.cast(key, OpenSSLRSAPrivateKey);
console.log("[*] Private Key Encoded: " + bytesToHex(priv_key.getEncoded()));
```

Output:

```
[*] script loaded
[Android Emulator 5554::sg.vp.owasp_mobile.OMTG_Android]-> [*] decryptString called
[*] alias: Dummy
[*] OpenSSLKey.isEngineBased called
[*] Cipher.init called
[*] mode: 2
[*] decryption with private key!
[*] OpenSSLKey.isEngineBased called
[*] Private Key encoded: [object Object]
```

So now we get something, but it is an _Object_. We know that it has to return a byte array so let's convert this object to a byte array. Add this little method at the beginning of your script and aplly it to the `getEncoded` call:

```
function bytesToHex(bytes) {
    for (var hex = [], i = 0; i < bytes.length; i++) { hex.push(((bytes[i] >>> 4) & 0xF).toString(16).toUpperCase());
        hex.push((bytes[i] & 0xF).toString(16).toUpperCase());
        hex.push(" ");
    }
    return hex.join("");
}
...
  console.log("[*] Private Key Encoded: " + bytesToHex(priv_key.getEncoded()));
...
```

So at the end we get the key:
```

[Xiaomi Redmi Note 2::sg.vp.owasp_mobile.OMTG_Android]-> [*] decryptString called
[*] alias: Dummy
[*] OpenSSLKey.isEngineBased called
[*] Cipher.init called
[*] mode: 2
[*] private key!
[*] OpenSSLKey.isEngineBased called
[*] Private Key Encoded: 30 82 01 27 02 01 00 30 0D 06 09 2A 86 48 86 F7 0D 01 01 01 05 00 04 82 01 11 30 82 01 0D 02 01 00 02 82 01 01 00 D1 E2 A4 E0 2B 4B 85 08 34 C0 69 D7 C3 5F 1E D9 DC 32 4E 73 7C 6A 1F 76 CA 79 C2 25 A1 9F A0 53 93 F0 1C AB 1F FD D1 E7 E8 DC 65 60 B1 2F 34 16 BF BA 4C B5 81 0F 64 5B EB AB 78 21 A9 A8 FE 9C 4C DA F0 04 FF 28 B3 F2 2D 3D 09 B3 F2 51 52 CE 24 DD F3 4E 71 39 13 2E C2 B1 39 59 49 B6 64 52 B7 7B 7D BA 17 50 AF 46 CF C3 0B 44 06 38 14 A6 79 28 95 97 F3 3B 6E E7 CD B6 88 86 D4 61 B8 5E F3 2D 6F B9 97 B6 89 96 D8 42 4D 37 C2 27 18 23 9C 48 E6 85 40 F7 B1 D9 9E 10 92 5B E9 FC 59 CB A1 F0 8E 2C A8 1C 83 E3 1C A8 CA A8 C4 FE 02 37 67 A3 06 E3 E4 A1 FC A1 34 9E 00 94 A4 75 5B DB 3F BF 8E 66 54 CA EA CD 38 45 70 D7 7E A4 BB EA 81 B6 18 5C 90 D6 96 78 30 93 0B C1 89 2E A5 CD 59 0A 0F 62 75 8E 33 E9 50 A3 DD FC 26 3D E2 DA 6E 1C 71 5D D4 1D 42 16 A8 58 EC 43 92 18 CA 69 02 03 01 00 01
```

If you have worked long enough with cryptography (for example programming JavaCards) you will see immediately that it is ASN.1 encoded key. If not, now you know this :) Let's decode it (online):
<https://lapo.it/asn1js/#30820127020100300D06092A864886F70D0101010500048201113082010D0201000282010100D1E2A4E02B4B850834C069D7C35F1ED9DC324E737C6A1F76CA79C225A19FA05393F01CAB1FFDD1E7E8DC6560B12F3416BFBA4CB5810F645BEBAB7821A9A8FE9C4CDAF004FF28B3F22D3D09B3F25152CE24DDF34E7139132EC2B1395949B66452B77B7DBA1750AF46CFC30B44063814A679289597F33B6EE7CDB68886D461B85EF32D6FB997B68996D8424D37C22718239C48E68540F7B1D99E10925BE9FC59CBA1F08E2CA81C83E31CA8CAA8C4FE023767A306E3E4A1FCA1349E0094A4755BDB3FBF8E6654CAEACD384570D77EA4BBEA81B6185C90D6967830930BC1892EA5CD590A0F62758E33E950A3DDFC263DE2DA6E1C715DD41D4216A858EC439218CA690203010001>

And this is what we obtain:
```
SEQUENCE (3 elem)
  INTEGER 0
  SEQUENCE (2 elem)
    OBJECT IDENTIFIER 1.2.840.113549.1.1.1 rsaEncryption (PKCS #1)
    NULL
  OCTET STRING (1 elem)
    SEQUENCE (3 elem)
      INTEGER 0
      INTEGER (2048 bit) 264955680822062441736494697063059182468383133853593313987249789454655…
      INTEGER 65537
```

To know what this means we can check the corresponding [RFC2313][]:

```
7.2 Private-key syntax

   An RSA private key shall have ASN.1 type RSAPrivateKey:

   RSAPrivateKey ::= SEQUENCE {
     version Version,
     modulus INTEGER, -- n
     publicExponent INTEGER, -- e
     privateExponent INTEGER, -- d
     prime1 INTEGER, -- p
     prime2 INTEGER, -- q
     exponent1 INTEGER, -- d mod (p-1)
     exponent2 INTEGER, -- d mod (q-1)
     coefficient INTEGER -- (inverse of q) mod p }
```

so we can see that we have the version, which is 0 by default (see RFC: `  o    version is the version number, for compatibility future revisions of this document. It shall be 0 for this version of the document.`).

Then we have the modulus and the public exponent. However, no private exponent is provided.

We can also verify that both the public exponent as well as the modulus are the same as the ones we found before:
```
[*] key PublicExponent: 65537
[*] key modulus: 26495568082206244173649469706305918246838313385359331398724978945465506341665951290493778801259416540286329379556845776505481398074467617269794707688853240403204215416194308987107727462842744294614925414414905979124814093165582594632176536010453668292524078994531305019434023144116572380347938647301369880231616210005277263662446448301511635565803020915749213943100214444734872059913408725945258265989516104409186654011048149783773489719936532452426398183261176160254380855063689237225968819411931353577474454010045704279861068417686809912170611519699127687195529522437204573348421439338441847261241515264706107460201
```

A final note about the javascript exceptions. If you use try catch blocks you will get more valuable information:

Running this:
```
 try {
  console.log("[*] key PrivateExponent: " + priv_key.getPrivateExponent());
}
catch (err){
  console.log("[*] Exception in priv_key.getPrivateExponent(): " + err.message);
}
```
Gives:
```
[*] Exception in priv_key.getPrivateExponent(): java.lang.NullPointerException: privateExponent == null
```

If we don't do this we don't even get a log because the exception is thrown and breaks `console.log`.

## Android 7
The current code for this is in [OMTG_DATAST_001_KeyStore][] (commit 86840fd).

Newer versions of android use a different class for the private key, that is [AndroidKeyStoreRSAPrivateKey][].

- This class only implements the `getModulus` method.
- It extends [AndroidKeyStorePrivateKey][] and implements [RSAKey][].
- [AndroidKeyStorePrivateKey][] extends [AndroidKeyStoreKey][] implements [PrivateKey][].

After inspection, we still cannot find methods to get the privateExponent. So there is no method we can hook to even try get it.

# Conclusion

We could get the public keys but _unfortunately_ not the private key. That is actually good as we can verify this way that our crypto keys are protected from extraction even on runtime.

Now that you have these scripts I invite you to use them as skeleton and inspiration to write more scripts and hook and bypass other stuff in all kind of apps. Start playing around with frida! For example you can disable certificate pinning, remove checks for a rooted device/emulator, read traffic sent to the internet or via bluetooth... Your imagination is the limit ;)
___

[OMTGApp]: https://github.com/OWASP/MSTG-Hacking-Playground/blob/master/Android/OMTG-Android-App/
[OMTG_DATAST_001_KeyStore_f412226f1b]: https://github.com/OWASP/MSTG-Hacking-Playground/blob/f412226f1bac1958d3f71b0d19eca0dc0905a267/Android/OMTG-Android-App/app/src/main/java/sg/vp/owasp_mobile/OMTG_Android/OMTG_DATAST_001_KeyStore.java#LC173
[OMTG_DATAST_001_KeyStore]: https://github.com/OWASP/MSTG-Hacking-Playground/blob/master/Android/OMTG-Android-App/app/src/main/java/sg/vp/owasp_mobile/OMTG_Android/OMTG_DATAST_001_KeyStore.java
[x86fridaserver]:  https://github.com/frida/frida/releases/download/11.0.3/frida-server-11.0.3-android-x86.xz
[x8664fridaserver]: https://github.com/frida/frida/releases/download/11.0.3/frida-server-11.0.3-android-x86_64.xz
[RSAPublicKey]: https://developer.android.com/reference/java/security/interfaces/RSAPublicKey]
[RSAPrivateKey]: https://developer.android.com/reference/java/security/interfaces/RSAPrivateKey]
[RSAKey]: https://developer.android.com/reference/java/security/interfaces/RSAKey]
[PrivateKey]: https://developer.android.com/reference/java/security/PrivateKey
[Cipher]: https://developer.android.com/reference/javax/crypto/Cipher
[OpenSSLRSAPrivateKey]: https://android.googlesource.com/platform/libcore/+/android-4.4.2_r1/crypto/src/main/java/org/conscrypt/OpenSSLRSAPrivateKey.java
[OpenSSLKey]: https://android.googlesource.com/platform/external/conscrypt/+/f087968/src/main/java/org/conscrypt/OpenSSLKey.java
[RFC2313]: https://tools.ietf.org/html/rfc2313
[AndroidKeyStoreRSAPrivateKey]: https://android.googlesource.com/platform/frameworks/base/+/c58153b/keystore/java/android/security/keystore/AndroidKeyStoreRSAPrivateKey.java
[AndroidKeyStorePrivateKey]: https://android.googlesource.com/platform/frameworks/base/+/master/keystore/java/android/security/keystore/AndroidKeyStorePrivateKey.java
[AndroidKeyStoreKey]: https://android.googlesource.com/platform/frameworks/base/+/master/keystore/java/android/security/keystore/AndroidKeyStoreKey.java
